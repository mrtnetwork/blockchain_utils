import 'package:blockchain_utils/bip/ecc/keys/sr25519_keys.dart';
import 'package:blockchain_utils/bip/substrate/conf/substrate_coins.dart';
import 'package:blockchain_utils/bip/substrate/substrate_base.dart';
import 'package:blockchain_utils/bip/substrate/substrate_path.dart';
import 'package:blockchain_utils/utils/utils.dart';
import 'package:test/test.dart';

import '../quick_hex.dart';
import 'test_vector.dart';

void main() {
  test("substrate test from private key", () {
    /// test from private key and derive
    for (final i in testVector) {
      final seed = BytesUtils.fromHexString(i["private_key"]);
      final coin = SubstrateCoins.values.firstWhere((element) =>
          element.name.toLowerCase() ==
          (i["coin"] as String).toLowerCase().replaceAll("_", ""));
      Substrate w = Substrate.fromPrivateKey(seed, coin);
      expect(w.publicKey.compressed.toHex(), i["public_key"]);
      expect(w.priveKey.raw.toHex(), i["private_key"]);
      expect(w.publicKey.toAddress, i["address"]);
      final child = List.from(i["child"]);
      for (int c = 0; c < child.length; c++) {
        final childInfo = child[c];
        final path = SubstratePathElem(childInfo["path"]);
        w = w.childKey(path);
        expect(w.publicKey.compressed.toHex(), childInfo["public_key"]);
        expect(w.publicKey.toAddress, childInfo["address"]);
        if (path.isHard) {
          expect(w.priveKey.raw.toHex(), childInfo["private_key"]);
        } else {
          /// for soft derive only first 32 bytes of secret key is equal
          /// and last 32 bytes of secret key (NONCE) generated by random
          final secret = (w.priveKey.privKey as Sr25519PrivateKey).secretKey;
          final testPrive =
              BytesUtils.fromHexString(childInfo["private_key"]).sublist(0, 32);
          expect(BytesUtils.bytesEqual(testPrive, secret.key()), true);
        }
      }
    }
  });

  /// test from seed and derive

  test("test from seed and derive", () {
    for (final i in testVector) {
      final seed = BytesUtils.fromHexString(i["seed"]);
      final coin = SubstrateCoins.values.firstWhere((element) =>
          element.name.toLowerCase() ==
          (i["coin"] as String).toLowerCase().replaceAll("_", ""));
      Substrate w = Substrate.fromSeed(seed, coin);
      expect(w.publicKey.compressed.toHex(), i["public_key"]);
      expect(w.priveKey.raw.toHex(), i["private_key"]);
      expect(w.publicKey.toAddress, i["address"]);
      final child = List.from(i["child"]);
      for (int c = 0; c < child.length; c++) {
        final childInfo = child[c];
        final path = SubstratePathElem(childInfo["path"]);
        w = w.childKey(path);
        expect(w.publicKey.compressed.toHex(), childInfo["public_key"]);
        expect(w.publicKey.toAddress, childInfo["address"]);
        if (path.isHard) {
          expect(w.priveKey.raw.toHex(), childInfo["private_key"]);
        } else {
          /// for soft derive only first 32 bytes of secret key is equal
          /// and last 32 bytes of secret key (NONCE) generated by random
          final secret = (w.priveKey.privKey as Sr25519PrivateKey).secretKey;
          final testPrive =
              BytesUtils.fromHexString(childInfo["private_key"]).sublist(0, 32);
          expect(BytesUtils.bytesEqual(testPrive, secret.key()), true);
        }
      }
    }
  });
}
